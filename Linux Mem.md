
# Linux 内存管理
- 内核态和用户态
- 高端内存
- vmalloc 和 kmalloc
- 其他内存函数介绍
- 64位下内存布局
- VMA介绍
- PAE

***
## 内核态和用户态
对于32位的Linux内核， 共有4G的地址空间, 其中0～3G是用户态空间，3~4G是内核态空间。

```c
Fig
                Address Space
0xffffffff +-------------------+
           |                   |
           |    Kernel Mode    |
           |                   |
0xc0000000 +-------------------+
           |                   |
           |                   |
           |                   |
           |                   |
           |    User   Mode    |
           |                   |
           |                   |
           |                   |
           |                   |
0x00000000 +-------------------+
```
刚才说的是**地址空间**, 而不是实际的**物理内存**。对于物理内存 用户进程只能访问3G内存，
而内核可以访问所有内存，也就是说Linux内核能访问所有4G内存，如果物理机器上不止4G物理
内存，那么内核应该都能访问。但是内核的地址空间却只有1G，如果进行简单的一一映射，那么
内核只能访问1G的物理内存。如下图所示，通过将内核地址减去一个固定偏移PAGE_OFFSET，可以
得到内存的物理地址。
          Address Space = Physical Memory + 0xc0000000
所以，如果就不能进行简单一一映射。

```c
Fig:
                                             Physical Memory

                                         +---------------------+ 0xffffffff
                                         |                     |
                                         |                     |
                                         |                     |
                                         |                     |
                                         |        >=3 GB       |
                                         |                     |
                                         |                     |
              Address Space              |                     |
                                         |                     |
0xffffffff +-------------------+ +-----> +---------------------+ 0x40000000
           |                   | |-----> |                     |
           |    Kernel Mode    | |-----> |        1 GB         |
           |                   | |-----> |                     |
0xc0000000 +-------------------+ +-----> +---------------------+ 0x00000000
           |                   |
           |                   |
           |                   |
           |                   |
           |    User   Mode    |
           |                   |
           |                   |
           |                   |
           |                   |
0x00000000 +-------------------+
```
## 高端内存
所以不能进行简单的一一映射。因此Linux中内核地址分成分成三部分
- ZONE_DMA          0 ～ 16MB
kmalloc和get_free_pages使用GFP_DMA标志，便是从该区域获取内存。
该区域专门供IO设备使用，之所以需要单独管理DMA的物理页面，是因为DMA使用物理地址访问
内存，不经过MNMU，并且需要连续的缓冲区，所以为了能够提供物理上连续的换红区，必须从物理
地址空间专门划分一段区域用于DMA。这些设备主要是一些ISA设备和未实现全部PCI标准的PCI设备。
但是，现在的架构，由于有IOMMU的存在，可以从其他内核区域为DMA分配内存，然后使用IOMMU将
分配的物理缓冲区映射成连续的总线地址。

- ZONE_NORMAL       16MB~896MB
与内核线性地址空间是一一映射的，存储一些频繁使用的数据，如Kernel代码，GPT，IDT，PGD
和mem_map等等
- ZONE_HIGHMEM      896MB ~ end
多存储用户数据，页表等不常用数据，在要访问这些数据时才建立映射关系(kmap)

如下图所示：

```c
Fig:

                                                    Physical Memory
                                           +----> +--------------------+
                                           |      |                    |
                                           |      |                    |
                                           |      |                    |
                                           |      |    >= 1GB Mem      |
                                           |      |                    |
                                           |      |                    |
                                           |      |                    |
                 Address Space             |      |                    |
                                           |      |                    |
0xffffffff    +---------------------+ +----+      +--------------------+
              |                     |             |                    |
              |     ZONE_HIGHMEM    |             |    896MB - ...     |
              |                     |             |                    |
0xf8000000    +---------------------+ +---------> +--------------------+
              |                     |             |                    |
              |                     |             |                    |
              |                     |             |                    |
              |     ZONE_NORMAL     |             |     16-896MB       |
              |                     |             |                    |
              |                     |             |                    |
              |                     |             |                    |
              |                     |             |                    |
              +---------------------+ +---------> +--------------------+
              |                     |             |                    |
              |      ZONE_DMA       |             |     16 MB          |
              |                     |             |                    |
0xc0000000    +---------------------+ +---------> +--------------------+ 0x00000000
              |                     |
              |      User Mode      |
              |                     |
0x00000000    +---------------------+
```

高端内存怎么用呢？

当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小
空闲的逻辑地址空间，借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表）
，临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间
，访问所有所有物理内存。如下图。
```c
Fig:
                                                        Physical Memory
                                                   +--------------------+
                                                   |                    |
                                                   |                    |
                   Address Space                   |                    |
                                                   |                    |
0xffffffff    +---------------------+              |                    |
              |                     |              |                    |
     ^        |                     |              |                    |
     |        +---------------------+ +----------> +--------------------+
     |        |   temp addr space   |              |  use the high mem  |
     +        +---------------------+ +----------> +--------------------+
              |                     |              |                    |
ZONE_HIGHMEM  |                     |              |                    |
              |                     |              |                    |
     +        |                     |              |                    |
     |        |                     |              |                    |
     v        |                     |              |                    |
              |                     |              |                    |
0xf8000000    +---------------------+ +----------> +--------------------+
              |                     |              |                    |
              |                     |              |    0 - 896MB       |
              |                     |              |                    |
0xc0000000    +---------------------+ +----------> +--------------------+
              |                     |
              |      User Mode      |
              |                     |
0x00000000    +---------------------+
```


高端内存的基本思路是：随用随借，用完归还。但是如果有内核进程或者模块占用着逻辑地址空间不释放，
便会造成内核的高端内存地址空间越来越紧张。因此，内核讲高端内存划分为三个部分。

- 动态内存映射区:
该区域由内核函数vmalloc来分配，特点是：线性空间连续，但是对应的物理空间不一定连续。
vmalloc分配的线性地址所对应的物理页可能处于低端内存，也可能处于高端内存。

- 永久内存映射区：
该区域可访问高端内存。访问方法是使用alloc_page(_GFP_HIGHMEM)分配高端内存页或者使用
kmap函数将分配到的高端内存映射到该区域。

- 固定映射区：
该区域和4G的顶端只有4k的隔离带，其每个地址项都服务于特定的用途，如ACPI_BASE等。

- 直接映射区：
线性空间中从3G开始最大896M的区间，为直接内存映射区，该区域的线性地址和物理地址存在线性
转换关系：线性地址=3G+物理地址。


## 内核逻辑地址 与内核虚拟地址的区别

## vmalloc和kmalloc的区别

1. kmalloc/kfree，分配的内存处于3GB～high_memory之间，这段内核空间与物理内存的映射
一一对应，可以分配连续的物理内存

2. vmalloc对应于vfree，分配的内存在VMALLOC_START～4GB之间，分配连续的虚拟内存，但是物理
上不一定连续。

3. vmalloc() 分配的物理地址无需连续，而kmalloc() 确保页在物理上是连续的

4. kmalloc分配内存是基于slab，因此slab的一些特性包括着色，对齐等都具备，性能较好。
物理地址和逻辑地址都是连续的。 最主要的区别是分配大小的问题，比如你需要28个字节，
那一定用kmalloc，如果用vmalloc，分配不多次机器就罢工了。 尽管仅仅在某些情况下才需要物
理上连续的内存块，但是，很多内核代码都调用kmalloc()，而不是用vmalloc()获得内存。这主要
是出于性能的考虑。vmalloc()函数为了把物理上不连续的页面转换为虚拟地址空间上连续的页，
必须专门建立页表项。还有，通过 vmalloc()获得的页必须一个一个的进行映射（因为它们物理上
不是连续的），这就会导致比直接内存映射大得多的缓冲区刷新。因为这些原因，vmalloc()仅在绝
对必要时才会使用，最典型的就是为了获得大块内存时，例如，当模块被动态插入到内核中时，就把
模块装载到由vmalloc()分配的内存上。


## 进程页表和内核页表




## 总线地址，虚拟地址和物理地址

- 物理地址可以理解为 物理内存上的硬件地址
- CPU通过MMU来访问物理内存，MMU将物理地址映射为虚拟地址
- DEV通过IOMMU来访问物理内存，IOMMU将物理地址映射为总线地址。
- 映射的原理就是建立页表，MMU和IOMMU可以拥有各自独立的页表，也可以共享一份页表。
MMU和IOMMU分别是CPU和DEV的眼睛，共用一份页表，就是使用同一双眼睛来看内存。

```c
Fig:
+--------------------------------------------+
|                                            |
|             Physical Memory                |
|                                            |
|                                            |
+----------------------+---------------------+
                       ^
                       |
                       |
              +--------+----------+
              |                   |
     +------> |     Mem Arbiter   | <------+
     |        |                   |        |
     |        +-------------------+        |
  +--+--+                              +---+---+
  |     |        +-----+  +-----+      |       |
  | MMU | <----+ | CPU |  | DEV | +--> | IOMMU |
  |     |        +-----+  +-----+      |       |
  +-----+                              +-------+

```

## 内存空洞
